# BOJ_SourceCode

## <백준 Problem Solving>


### 1. 백준 2178번: 미로 탐색
-------------------------
<img width="968" alt="스크린샷 2020-08-05 오후 5 38 40" src="https://user-images.githubusercontent.com/67541842/89391009-8eb10280-d742-11ea-9011-ed48fc9ecbd4.png">

#### 설명: 
    이 문제는 탐색 알고리즘인 BFS를 이용하여 풀 수 있다.       
    처음에는 비교적 구현하기 간단한 DFS를 이용하여 풀고자 하였으나 timeout으로 통과가 되지 않아서 BFS로 다시 풀었다.        
    먼저 위치좌표 (x,y)를 표현하기 위한 pos 구조체와 미로를 저장하는 배열, 방문여부를 저장하는 배열을 선언한다.         
    그리고 BFS에 필요한 큐를 선언하는데 이때 변수타입은 위에서 선언한 pos 구조체로 하여, 방문기록을 x와 y값을 한 번에 저장하도록 한다.       
    BFS로 미로를 풀기 위해서는 현재 위치에서 갈 수 있는 동,서,남,북 네 방향을 모두 확인하여 조건에 맞을 경우 큐에 넣어줘야 하는데          
    간단한 반복문을 이용해 이를 구현하기 위해서 방향을 구현하는 xpos, ypos 두 배열변수를 선언한다.      
    적절한 조건을 사용하여 bfs함수를 구현하여 정답이 출력되도록 하였다.        


### 2. 백준 10164번: 격자상의 경로
-------------------------
<img width="956" alt="스크린샷 2020-08-05 오후 5 23 28" src="https://user-images.githubusercontent.com/67541842/89389521-7a6c0600-d740-11ea-9488-52bcad5e5678.png">

#### 설명:      
         
이 문제는 조합의 곱으로 경우의 수를 구하는 공식을 사용하여 풀 수 있다.       
조합을 구해주는 함수 combination을 반복문을 이용하여 만들어 사용하였다.
세가지 경우를 나눠서 생각할 수 있는데 각각의 경우는 아래와 같다.
    
    * 꼭 거쳐야 하는 번호가 없는 경우     
    * 각 행의 마지막 열에 해당하는 번호를 거쳐가야하는 경우       
    * 그 외에 나머지의 경우     
           
       
각각의 경우에 맞게 조합에 넣을 숫자를 지정하여 정답이 나오도록 구현하였다.


### 3. 백준 11727번: 2Xn 타일링 2
-------------------------
<img width="605" alt="스크린샷 2020-08-05 오후 5 00 08" src="https://user-images.githubusercontent.com/67541842/89387306-46431600-d73d-11ea-899e-d07e5566a84e.png">

#### 설명:
        
이 문제는 경우의 수를 이용하여 적용가능한 점화식을 먼저 구해야 한다.       
f(n)이 타일의 가로 길이가 n일때 경우의 수라고 했을 때, 마지막에 오는 타일 종류를 이용하여 아래 세가지 경우를 구할 수 있다.      
* case 1: 맨 마지막에 2x1 타일이 오는 경우      
         
      이 경우에는 타일의 가로 길이가 n-1만큼 남게 되므로 f(n-1)을 구하면 된다.        
* case 2: 맨 마지막에 2x2 타일이 오는 경우    
       
      이 경우에는 타일의 가로 길이가 n-2만큼 남게 되므로 f(n-2)을 구하면 된다.     
* case 3: 맨 마지막에 1x2 타일이 두 개 겹쳐져 있는 경우    
      
      이 경우에는 타일의 가로 길이가 n-2만큼 남게 되므로 f(n-2)을 구하면 된다.        
         
          
따라서 점화식은  f(n) = f(n-1) + f(n-2) * 2   가 된다.       
* n = 1 일 때, 경우의 수는 1 이므로 f(1) = 1      
* n = 2 일 때, 경우의 수는 3 이므로 f(2) = 3     
위의 두 수를 초기 값으로 주고 경우에 따라 정답을 구하도록 구현하였다.       

           
           
### 4. 백준 1034번: 램프
-------------------------
<img width="754" alt="스크린샷 2020-08-05 오후 4 25 29" src="https://user-images.githubusercontent.com/67541842/89384262-c87d0b80-d738-11ea-8c78-da162b89fc92.png">

#### 설명:      
        
        
    우선 한 행이 켜져있기 위해서는 해당하는 행의 상태가 모두 1이어야 하는데        
    결과적으로 정답으로 나오는 행의 최대 개수는 조건을 만족하는 초기 상태가 동일한 행의 최대값이라고 볼 수 있다.       
    초기상태가 동일한 것을 비교할 때 비효율적인 반복문 사용을 피하기 위해서는        
    처음부터 램프의 상태를 저장하는 2차원배열 변수의 형태를 char로 두어 각 행에 문자열로 값을 받아 저장할 수 있도록 한다.      
    결국 string.h 헤더파일에 들어있는 strcmp 함수로 쉽게 두 행의 일치여부를 확인할 수 있게 된다.     
    문제를 풀기 위해서 우선 각 행이 k번의 스위치 조작으로 켜진 상태가 될 수 있는지 확인해야 하는데       
    k가 홀수이면 초기에 꺼져있는 램프 개수도 홀수여야하고 짝수이면 초기에 꺼져있는 램프 개수도 역시 짝수가 되어야한다.          
    위의 조건들을 토대로 적절한 반복문을 사용하여 정답이 나오도록 구현하였다.     
